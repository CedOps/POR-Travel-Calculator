<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Team Travel Checker ‚Äî POR</title>

<link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>

<link rel="stylesheet" href="https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.1/dist/mapbox-gl-geocoder.css" />
<script src="https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.1/dist/mapbox-gl-geocoder.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  html,body{height:100%;margin:0}
  #map{position:absolute;inset:0}
  #status{
    position:fixed;left:8px;top:8px;z-index:1000;background:#fff;border:1px solid #e5e7eb;border-radius:12px;
    padding:10px 12px;font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial;box-shadow:0 1px 6px rgba(0,0,0,.12);max-width:760px;
    pointer-events:auto;
  }
  #status .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:4px 0}
  #status .pill{border:1px solid #e5e7eb;border-radius:999px;padding:3px 8px;font-size:12px}
  #status .ok{color:#065f46;background:#d1fae5;border-color:#10b981}
  #status .warn{color:#7f1d1d;background:#fee2e2;border-color:#ef4444}
  #status .muted{color:#6b7280;font-size:12px}
  #status b{font-weight:600}
  .u{text-decoration:underline}

  details.alt{margin-top:6px;border-top:1px dashed #e5e7eb;padding-top:6px}
  details.alt > summary{
    cursor:pointer; list-style:none; padding:4px 8px; border-radius:8px;
    border:1px solid #e5e7eb; display:flex; align-items:center; gap:8px;
    background:#f9fafb;
  }
  details.alt[open] > summary{background:#eef2ff;border-color:#c7d2fe}
  .alt-body{
    margin:8px 0 2px 0; padding:8px; border:1px solid #eef2f7;
    border-radius:8px; background:#fff
  }
  .chips{margin-top:6px}

  /* Toast */
  #toast{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    background:#111827; color:#fff; padding:8px 12px; border-radius:10px;
    font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    opacity:0; pointer-events:none; z-index:10000;
    box-shadow:0 8px 24px rgba(0,0,0,.25); transition:opacity .25s ease;
  }
  #toast.show{opacity:0.95}
</style>
</head>
<body>
<div id="map"></div>
<div id="status">Starting‚Ä¶</div>
<div id="toast">C.C.</div>

<script>
(() => {
  // ====== CONFIG ======
  const MAPBOX_TOKEN = "pk.eyJ1IjoibWVpc3RlcmciLCJhIjoiY21mbWZ3MWljMDFmZzJsb2UyNzlvanhwdiJ9.ABrCTCsLUIcU0R7bXv_GbA";
  const CSV_URL      = "data.csv";            // file next to this HTML
  const COUNTRIES    = "AU";                  // geocoder restricted to AU

  const RATE_PER_KM   = 2.08;                 // ex-GST
  const GST_FACTOR    = 1.1;
  const FREE_KM       = 50;
  const CURRENCY      = "AUD";
  const AVG_SPEED_KPH = 80;                   // fallback straight-line time
  const ALT_COUNT     = 3;

  const NEAREST_COLOR = '#2563eb';            // blue
  const ALT_COLORS    = ['#f59e0b','#ef4444','#10b981']; // yellow, red, green

  const statusEl = document.getElementById('status');
  const toastEl  = document.getElementById('toast');
  const setStatus = html => statusEl && (statusEl.innerHTML = html);

  function showToast(msg='C.C.'){
    if(!toastEl) return;
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 2000);
  }
  // manual test: press T
  window.addEventListener('keydown', e => { if((e.key||'').toLowerCase()==='t') showToast(); });

  // Helpers
  const yn  = v => String(v||'').trim().toLowerCase()==='yes' || String(v||'').trim().toLowerCase()==='true';
  const num = v => { if(v==null) return NaN; const s=String(v).trim().replace(/[^\d.\-+eE]/g,''); return parseFloat(s); };
  const money = v => new Intl.NumberFormat('en-AU',{style:'currency',currency:CURRENCY,minimumFractionDigits:2,maximumFractionDigits:2}).format(v);
  const str = v => (v==null ? '' : String(v));

  function rowToFeature(row,id){
    const lat=num(row.Lat), lng=num(row.Lng);
    if (isNaN(lat) || isNaN(lng)) return null;
    row['Access Control']   = row['Access Control'] ?? row['AccessControl'] ?? '';
    row['Single Tech only'] = row['Single Tech only'] ?? row['SingleTechOnly'] ?? '';
    row.State = str(row.State).trim().toUpperCase();
    return { type:'Feature', id, geometry:{type:'Point', coordinates:[lng,lat]}, properties:row };
  }

  function loadCSV(url){
    return new Promise((resolve,reject)=>{
      Papa.parse(url,{download:true,header:true,skipEmptyLines:true,
        complete:res=>resolve(res.data), error:err=>reject(err)});
    });
  }

  async function getDriving(fromLngLat,toLngLat){
    const url=`https://api.mapbox.com/directions/v5/mapbox/driving/${fromLngLat[0]},${fromLngLat[1]};${toLngLat[0]},${toLngLat[1]}?overview=full&geometries=geojson&access_token=${MAPBOX_TOKEN}`;
    const res=await fetch(url);
    if(!res.ok) throw new Error(`Directions HTTP ${res.status}`);
    const json=await res.json();
    const route=json.routes && json.routes[0];
    if(!route) throw new Error('No route');
    return { km:route.distance/1000, minutes:route.duration/60, geometry:route.geometry };
  }

  function serviceChips(p){
    const base = ['CCTV','Alarm','Access Control','Install','Service'].map(k=>{
      const val = yn(p[k]);
      const color = val ? '#16a34a' : '#dc2626';
      const bg    = val ? '#dcfce7' : '#fee2e2';
      const border= val ? '#16a34a' : '#dc2626';
      return `<span style="padding:2px 6px;border:1px solid ${border};border-radius:12px;margin:2px;font-size:12px;background:${bg};color:${color};">${k}</span>`;
    }).join(' ');
    const single = yn(p['Single Tech only'])
      ? `<span style="padding:2px 8px;border:1px solid #dc2626;border-radius:12px;margin:2px;font-size:12px;background:#fee2e2;color:#dc2626;">Single Tech Only</span>`
      : '';
    return base + (single ? (' ' + single) : '');
  }

  function buildPopupHTML(p){
    const chipsHTML = serviceChips(p);
    const notes = (p.Notes && String(p.Notes).trim()) ? String(p.Notes).trim() : "";
    return `<div>
      <h3 style="margin:0 0 4px">${p.POR||''}, ${p.State||''}</h3>
      <div style="font-size:12px;color:#555;margin:6px 0"><strong>Preferred Resource:</strong> ${p['Preferred Resource']||'‚Äî'}</div>
      ${p.Phone?`<div>üìû ${p.Phone}</div>`:''}
      ${p.Email?`<div>‚úâÔ∏è <a href="mailto:${p.Email}">${p.Email}</a></div>`:''}
      <div style="margin-top:6px">${chipsHTML}</div>
      ${notes ? `<div style="margin-top:6px"><strong>Notes:</strong> ${notes}</div>` : ``}
    </div>`;
  }

  function addOrUpdateLine(map, id, color, geometry){
    if(!map.getSource(id)){
      map.addSource(id,{type:'geojson',data:{type:'FeatureCollection',features:[]}});
      map.addLayer({id, type:'line', source:id,
        paint:{'line-color':color,'line-width':3,'line-opacity':0.9}});
    }
    map.getSource(id).setData({
      type:'FeatureCollection',
      features: geometry ? [{type:'Feature',geometry,properties:{}}] : []
    });
    map.setLayoutProperty(id, 'visibility', geometry ? 'visible' : 'none');
  }

  function removeAltRoutes(map){
    ALT_COLORS.forEach((_,i)=>{
      const id=`route-alt-${i}`;
      if(map.getLayer(id)) map.removeLayer(id);
      if(map.getSource(id)) map.removeSource(id);
    });
  }

  // Get AU state (e.g., AU-VIC -> VIC) from geocoder result
  function getAUStateAbbrevFromGeocoder(result){
    const parts = (result && result.context) || [];
    const region = parts.find(p => (p.id||'').startsWith('region.'));
    const sc = region && region.short_code; // "AU-VIC"
    if(sc && sc.toUpperCase().startsWith('AU-')) return sc.slice(3).toUpperCase();
    return null;
  }

  // nearest POR in same state if available; else fallback to absolute nearest
  function nearestInStateOrFallback(coord, feats, stateAbbrev){
    const from = turf.point(coord);
    const sorted = arr => arr.sort((a,b)=>a.km-b.km);
    const inState = feats
      .filter(f => String(f.properties.State).toUpperCase() === stateAbbrev)
      .map(f => ({feature:f, km: turf.distance(from,f,{units:'kilometers'})}));
    if(inState.length) return {feature: sorted(inState)[0].feature, km: sorted(inState)[0].km, usedFallback:false};
    const all = feats.map(f => ({feature:f, km: turf.distance(from,f,{units:'kilometers'})}));
    return {feature: sorted(all)[0].feature, km: sorted(all)[0].km, usedFallback:true};
  }

  // alternates by straight-line distance
  function alternatesSorted(coord, feats, excludeId){
    const from = turf.point(coord);
    return feats
      .filter(f=>f.id!==excludeId)
      .map(f=>({ feature:f, slKm: turf.distance(from,f,{units:'kilometers'}) }))
      .sort((a,b)=>a.slKm-b.slKm)
      .slice(0, ALT_COUNT);
  }

  // Fit bounds for query + nearest + open alternates
  function updateFitBounds(map, queryCoord, nearestCoord, altCoords){
    const b = new mapboxgl.LngLatBounds();
    if(queryCoord) b.extend(queryCoord);
    if(nearestCoord) b.extend(nearestCoord);
    (altCoords||[]).forEach(c=>b.extend(c));
    if(!b.isEmpty()) map.fitBounds(b,{padding:80,maxZoom:10});
  }

  const altPopups = {};              // layerId => popup
  let nearestPopup = null;
  let queryCoordGlobal = null;
  let nearestCoordGlobal = null;
  const activeAltCoords = new Map(); // layerId -> [lng,lat]

  async function main(){
    try{
      setStatus('Initialising map‚Ä¶');
      mapboxgl.accessToken = MAPBOX_TOKEN;

      const map = new mapboxgl.Map({
        container:'map', style:'mapbox://styles/mapbox/streets-v12',
        center:[144.9631,-37.8136], zoom:6
      });
      map.addControl(new mapboxgl.NavigationControl(),'bottom-right');

      // Geocoder
      let gc=null;
      if(window.MapboxGeocoder){
        gc=new MapboxGeocoder({
          accessToken: MAPBOX_TOKEN,
          mapboxgl,
          marker:false,
          placeholder:'Search address or postcode‚Ä¶',
          countries: COUNTRIES
        });
        map.addControl(gc,'top-right');
      }

      // Load data
      setStatus('Loading <code>data.csv</code>‚Ä¶');
      const rows = await loadCSV(CSV_URL);
      if(!rows || !rows.length) throw new Error('data.csv loaded but has 0 rows');

      const feats=[]; let id=1;
      for(const r of rows){ const f=rowToFeature(r,id++); if(f) feats.push(f); }
      if(!feats.length) throw new Error('Parsed 0 pins (check Lat/Lng and headers)');

      // show toast once on page load/refresh
      showToast('C.C.');

      function ensurePointLayer(){
        if(!map.getSource('query-point')){
          map.addSource('query-point',{type:'geojson',data:{type:'FeatureCollection',features:[]}});
          map.addLayer({id:'query-point',type:'circle',source:'query-point',
            paint:{'circle-radius':5,'circle-color':'#111827','circle-stroke-color':'#fff','circle-stroke-width':1}});
        }
      }

      async function showNearestFrom(coord, stateAbbrev){
        try{
          ensurePointLayer();

          // clear previous
          addOrUpdateLine(map,'route-nearest',NEAREST_COLOR,null);
          Object.values(altPopups).forEach(p => p.remove());
          for (const k in altPopups) delete altPopups[k];
          if(nearestPopup){ nearestPopup.remove(); nearestPopup=null; }
          removeAltRoutes(map);
          activeAltCoords.clear();

          // query point
          map.getSource('query-point').setData({
            type:'FeatureCollection',
            features:[{type:'Feature',geometry:{type:'Point',coordinates:coord},properties:{}}]
          });
          queryCoordGlobal = coord;

          // nearest limited to state (fallback if none)
          const nearestSel = nearestInStateOrFallback(coord, feats, stateAbbrev);
          const nearest = nearestSel.feature;
          let slKm = nearestSel.km;

          // compute route (use road only if >50km)
          let km=slKm, mins=(slKm/AVG_SPEED_KPH)*60, mode='straight', routeGeom=null;
          if(slKm>FREE_KM){
            try{
              const r=await getDriving(coord,nearest.geometry.coordinates);
              km=r.km; mins=r.minutes; mode='driving'; routeGeom=r.geometry;
            }catch(err){ console.warn('Nearest directions failed; using straight-line',err); }
          }
          if(!routeGeom){
            routeGeom={type:'LineString',coordinates:[coord,nearest.geometry.coordinates]};
          }
          addOrUpdateLine(map,'route-nearest',NEAREST_COLOR,routeGeom);
          nearestCoordGlobal = nearest.geometry.coordinates;

          // popup on nearest
          nearestPopup = new mapboxgl.Popup({offset:12, closeOnClick:false})
            .setLngLat(nearest.geometry.coordinates)
            .setHTML(buildPopupHTML(nearest.properties))
            .addTo(map);

          const within50 = km<=FREE_KM;
          const badgeClass = within50 ? 'ok' : 'warn';
          const badgeText  = within50 ? 'Within 50 km' : 'Outside 50 km';
          const outOfStateNearest = String(nearest.properties.State).toUpperCase() !== String(stateAbbrev).toUpperCase();

          // Accommodation pill: only when Outside 50 km AND (km >= 250 OR mins >= 150) one-way
          const accomFlag = (!within50) && (km >= 250 || mins >= 150);

          let travelCost = 0;
          if(!within50){
            const chargeableKm = Math.max(0, km - FREE_KM);
            travelCost = chargeableKm * 2 * RATE_PER_KM * GST_FACTOR;
          }

          const p=nearest.properties;
          const modeLabel = mode==='driving' ? 'road' : 'straight-line';
          const chipsHTML = serviceChips(p);

          // alternates (straight-line sort)
          const alts = alternatesSorted(coord, feats, nearest.id);
          const altHtml = alts.map((a, i) => {
            const pf = a.feature.properties;
            const altWithin = a.slKm <= FREE_KM;
            const cls = altWithin ? 'ok':'warn';
            const txt = altWithin ? 'Within 50 km' : 'Outside 50 km';
            const isOutOfState = String(pf.State).toUpperCase() !== String(stateAbbrev).toUpperCase();
            return `
              <details class="alt" data-alt-index="${i}">
                <summary>
                  <span>Alternate POR: ${pf.POR}, ${pf.State||''}</span>
                  <span class="pill ${cls}">${txt}</span>
                  ${isOutOfState ? `<span class="pill warn">Out of State</span>` : ``}
                  <span class="pill warn accom-pill" style="display:none">Accommodation may be required - Check with SDC</span>
                </summary>
                <div class="alt-body" style="display:none"></div>
              </details>
            `;
          }).join('');

          // status card
          setStatus(`
            <div class="row">
              <div><b>Nearest POR:</b> <span class="u">${p.POR}, ${p.State||''}</span></div>
              <div class="pill ${badgeClass}">${badgeText}</div>
              ${outOfStateNearest ? `<div class="pill warn">Out of State</div>` : ``}
              ${accomFlag ? `<div class="pill warn">Accommodation may be required - Check with SDC</div>` : ``}
            </div>
            <div class="row">
              <div class="pill"><b>Distance (One Way):</b> ${km.toFixed(1)} km <span class="muted">(${modeLabel})</span></div>
              <div class="pill"><b>Est. Time (One Way):</b> ${Math.round(mins)} min</div>
              <div class="pill">
                <b>Travel Charge inc GST:</b> ${money(travelCost)} 
                <span class="muted">(${money(RATE_PER_KM)} / km ex GST)</span>
              </div>
            </div>
            <div class="row"><div><b>Preferred Resource:</b> ${p['Preferred Resource']||'‚Äî'}</div></div>
            <div class="row">${chipsHTML}</div>
            ${(p.Notes && String(p.Notes).trim())
              ? `<div class="row"><div><b>Notes:</b> ${String(p.Notes).trim()}</div></div>`
              : ``}
            ${altHtml ? `<div class="row" style="margin-top:6px"><b>Alternates:</b></div>${altHtml}` : ''}
          `);

          // attach alt handlers
          document.querySelectorAll('details.alt').forEach((el)=>{
            const idx = Number(el.dataset.altIndex);
            const alt  = alts[idx];
            const pf   = alt.feature.properties;
            const layerId = `route-alt-${idx}`;
            const color   = ALT_COLORS[idx % ALT_COLORS.length];
            const lngLat  = alt.feature.geometry.coordinates;

            if(!map.getSource(layerId)){
              addOrUpdateLine(map, layerId, color, null);
            }

            el.addEventListener('toggle', async ()=>{
              const body = el.querySelector('.alt-body');

              if(el.open){
                if(el.dataset.loaded !== '1'){
                  let akm = alt.slKm;
                  let amins = (akm/AVG_SPEED_KPH)*60;
                  let amode = 'straight';
                  let acost = 0;
                  let ageom = {type:'LineString',coordinates:[coord, lngLat]};

                  if(alt.slKm > FREE_KM){
                    try{
                      const r = await getDriving(coord, lngLat);
                      akm = r.km; amins = r.minutes; amode = 'driving';
                      ageom = r.geometry;
                    }catch(e){ console.warn('Alt directions failed; using straight-line'); }
                  }
                  if(akm > FREE_KM){
                    const chargeable = Math.max(0, akm - FREE_KM);
                    acost = chargeable * 2 * RATE_PER_KM * GST_FACTOR;
                  }

                  const altWithin50 = akm <= FREE_KM;
                  const accom = (!altWithin50) && (akm >= 250 || amins >= 150);
                  const pill = el.querySelector('.accom-pill');
                  if(pill) pill.style.display = accom ? 'inline-block' : 'none';

                  const chips = serviceChips(pf);
                  body.style.display='block';
                  body.innerHTML = `
                    <div class="row">
                      <div class="pill"><b>Distance (One Way):</b> ${akm.toFixed(1)} km <span class="muted">(${amode==='driving'?'road':'straight-line'})</span></div>
                      <div class="pill"><b>Est. Time (One Way):</b> ${Math.round(amins)} min</div>
                      <div class="pill"><b>Travel Charge inc GST:</b> ${money(acost)} <span class="muted">(${money(RATE_PER_KM)} / km ex GST)</span></div>
                    </div>
                    <div class="row"><div><b>Preferred Resource:</b> ${pf['Preferred Resource']||'‚Äî'}</div></div>
                    <div class="row chips">${chips}</div>
                    ${(pf.Notes && String(pf.Notes).trim())
                      ? `<div class="row"><div><b>Notes:</b> ${String(pf.Notes).trim()}</div></div>`
                      : ``}
                  `;
                  el.dataset.loaded='1';
                  el.dataset.geom = JSON.stringify(ageom);
                }

                const geom = JSON.parse(el.dataset.geom);
                addOrUpdateLine(map, layerId, color, geom);

                // open popup on that pin
                const popup = new mapboxgl.Popup({offset:12, closeOnClick:false})
                  .setLngLat(lngLat).setHTML(buildPopupHTML(pf)).addTo(map);
                altPopups[layerId] = popup;

                // include in viewport
                activeAltCoords.set(layerId, lngLat);
                updateFitBounds(map, queryCoordGlobal, nearestCoordGlobal, [...activeAltCoords.values()]);

              }else{
                addOrUpdateLine(map, layerId, color, null);
                if(altPopups[layerId]){ altPopups[layerId].remove(); delete altPopups[layerId]; }
                activeAltCoords.delete(layerId);
                updateFitBounds(map, queryCoordGlobal, nearestCoordGlobal, [...activeAltCoords.values()]);
              }
            }, {once:false});
          });

          // Initial fit: query + nearest
          updateFitBounds(map, queryCoordGlobal, nearestCoordGlobal, []);
        }catch(e){
          console.error(e);
          setStatus(`‚ùå Nearest calc error: ${e.message}`);
        }
      }

      // Map on load: add pins, rings, listeners
      map.on('load', () => {
        // Pins
        const fcPins={type:'FeatureCollection',features:feats};
        map.addSource('pins',{type:'geojson',data:fcPins});
        map.addLayer({id:'pins',type:'circle',source:'pins',
          paint:{'circle-radius':6,'circle-color':'#2563eb','circle-stroke-color':'#fff','circle-stroke-width':1}});
        map.on('mouseenter','pins',()=>map.getCanvas().style.cursor='pointer');
        map.on('mouseleave','pins',()=>map.getCanvas().style.cursor='');
        map.on('click','pins', e=>{
          const p=e.features[0].properties;
          new mapboxgl.Popup({offset:12})
            .setLngLat(e.features[0].geometry.coordinates)
            .setHTML(buildPopupHTML(p))
            .addTo(map);
        });

        // 50km circles
        const rings = feats
          .filter(f => (String(f.properties.Circle50||'').toLowerCase()==='true' || yn(f.properties.Circle50)))
          .map(f => turf.circle(f.geometry.coordinates, FREE_KM, {steps:64, units:'kilometers'}));
        map.addSource('rings',{type:'geojson',data:{type:'FeatureCollection',features:rings}});
        map.addLayer({id:'rings-outline',type:'line',source:'rings',paint:{'line-color':'#f59e0b','line-width':2,'line-dasharray':[2,2]}});
        map.addLayer({id:'rings-fill',type:'fill',source:'rings',paint:{'fill-color':'#f59e0b','fill-opacity':0.08}});

        // Fit to all pins initially
        const b=new mapboxgl.LngLatBounds(); feats.forEach(f=>b.extend(f.geometry.coordinates));
        if(!b.isEmpty()) map.fitBounds(b,{padding:60});
        setStatus(`Done. Loaded <b>${feats.length}</b> pins from <code>${CSV_URL}</code>. Use the search box (Australia only) to calculate distance/time/cost.`);

        if(gc){
          gc.on('result', e => {
            const center = e?.result?.center;
            const stateAbbrev = getAUStateAbbrevFromGeocoder(e?.result) || '';
            if (center) showNearestFrom(center, stateAbbrev);
          });
          gc.on('clear', () => {
            addOrUpdateLine(map,'route-nearest',NEAREST_COLOR,null);
            Object.values(altPopups).forEach(p => p.remove());
            for (const k in altPopups) delete altPopups[k];
            if(nearestPopup){ nearestPopup.remove(); nearestPopup=null; }
            removeAltRoutes(map);
            activeAltCoords.clear();
            if (map.getSource('query-point')) map.getSource('query-point').setData({type:'FeatureCollection',features:[]});
            setStatus('Cleared.');
          });
        }
      });

    }catch(e){
      console.error(e);
      setStatus(`‚ùå Fatal error: ${e.message}<br>Check that <code>${CSV_URL}</code> exists next to this file.`);
    }
  }

  main().catch(err=>{ console.error(err); setStatus(`‚ùå Startup error: ${err.message}`); });
})();
</script>
</body>
</html>
