<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Team Travel Checker ‚Äî POR</title>

<link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>

<link rel="stylesheet" href="https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.1/dist/mapbox-gl-geocoder.css" />
<script src="https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.1/dist/mapbox-gl-geocoder.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  html,body{height:100%;margin:0}
  #map{position:absolute;inset:0}
  #status{
    position:fixed;left:8px;top:8px;z-index:1000;background:#fff;border:1px solid #e5e7eb;border-radius:12px;
    padding:10px 12px;font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial;box-shadow:0 1px 6px rgba(0,0,0,.12);max-width:820px;
  }
  #status .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:4px 0}
  #status .pill{border:1px solid #e5e7eb;border-radius:999px;padding:3px 8px;font-size:12px}
  #status .ok{color:#065f46;background:#d1fae5;border-color:#10b981}
  #status .warn{color:#7f1d1d;background:#fee2e2;border-color:#ef4444}
  #status .muted{color:#6b7280;font-size:12px}
  #status b{font-weight:600}
  .u{text-decoration:underline}

  details.alt{margin-top:6px;border-top:1px dashed #e5e7eb;padding-top:6px}
  details.alt > summary{
    cursor:pointer; list-style:none; padding:4px 8px; border-radius:8px;
    border:1px solid #e5e7eb; display:flex; align-items:center; gap:8px;
    background:#f9fafb;
  }
  details.alt[open] > summary{background:#eef2ff;border-color:#c7d2fe}
  .alt-body{
    margin:8px 0 2px 0; padding:8px; border:1px solid #eef2f7;
    border-radius:8px; background:#fff
  }
  .chips{margin-top:6px}

  /* Rate Control (top-right) */
  .rate-ctrl{
    display:flex; align-items:center; gap:6px;
    background:#fff; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px;
    box-shadow:0 1px 6px rgba(0,0,0,.08);
    font:12px system-ui,-apple-system,Segoe UI,Roboto,Arial;
    margin-right:6px;
  }
  .rate-ctrl label{color:#374151; font-size:12px}
  .rate-ctrl select{font-size:12px; padding:4px 6px; border-radius:8px; border:1px solid #d1d5db; background:#fff}

  /* Wider search box */
  .mapboxgl-ctrl-top-right .mapboxgl-ctrl-geocoder {
    width: 540px;
    min-width: 540px;
    max-width: 640px;
  }
  @media (max-width: 800px) {
    .mapboxgl-ctrl-top-right .mapboxgl-ctrl-geocoder {
      width: 90vw;
      min-width: 0;
      max-width: 90vw;
    }
  }

  /* Toast */
  #toast{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    background:#111827; color:#fff; padding:8px 12px; border-radius:10px;
    font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    opacity:0; pointer-events:none; z-index:10000;
    box-shadow:0 8px 24px rgba(0,0,0,.25); transition:opacity .25s ease;
  }
  #toast.show{opacity:0.95}
</style>
</head>
<body>
<div id="map"></div>
<div id="status">Starting‚Ä¶</div>
<div id="toast">C.C.</div>

<script>
(() => {
  // ====== CONFIG (defaults; override via config.json) ======
  let RATES = { "Default": 2.08 };
  let RATE_PER_KM = 2.08;  // ex GST
  let GST_PERCENT = 0.10;
  let FREE_KM     = 50;
  let SL_TRIGGER_KM = 35;  // start road check when SL > 35 km
  let GRACE_KM    = 15;    // invisible grace on road distance

  const MAPBOX_TOKEN = "pk.eyJ1IjoibWVpc3RlcmciLCJhIjoiY21mbWZ3MWljMDFmZzJsb2UyNzlvanhwdiJ9.ABrCTCsLUIcU0R7bXv_GbA";
  const CSV_URL      = "data.csv";
  const COUNTRIES    = "AU";
  const CURRENCY     = "AUD";

  const AVG_SPEED_KPH = 80;
  const ALT_COUNT     = 3;
  const NEAREST_COLOR = '#2563eb';
  const ALT_COLORS    = ['#f59e0b','#ef4444','#10b981'];

  const statusEl = document.getElementById('status');
  const toastEl  = document.getElementById('toast');
  const setStatus = html => statusEl && (statusEl.innerHTML = html);
  const gstFactor = () => 1 + GST_PERCENT;

  function showToast(msg='C.C.'){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 2000);
  }
  window.addEventListener('keydown', e => { if((e.key||'').toLowerCase()==='t') showToast(); });

  async function loadConfig(){
    try{
      const res = await fetch('./config.json', {cache:'no-store'});
      if(!res.ok) return;
      const cfg = await res.json();
      if (cfg.rates){ RATES = cfg.rates; RATE_PER_KM = Number(Object.values(RATES)[0]) || RATE_PER_KM; }
      if (typeof cfg.gst === 'number') GST_PERCENT = cfg.gst;
      if (typeof cfg.freeKm === 'number') FREE_KM = cfg.freeKm;
      if (typeof cfg.slTriggerKm === 'number') SL_TRIGGER_KM = cfg.slTriggerKm;
      if (typeof cfg.graceKm === 'number') GRACE_KM = cfg.graceKm;
    }catch(e){ console.warn('Config not found or invalid; using defaults.', e); }
  }

  function createRateControl(){
    class RateControl {
      onAdd(map){
        const container = document.createElement('div');
        container.className = 'mapboxgl-ctrl rate-ctrl';
        const label = document.createElement('label'); label.textContent = 'Rate:';
        const sel = document.createElement('select');
        Object.entries(RATES).forEach(([name, val])=>{
          const opt = document.createElement('option');
          opt.value = String(val);
          opt.textContent = `${name} (${Number(val).toFixed(2)}/km ex GST)`;
          if (Math.abs(Number(val) - RATE_PER_KM) < 1e-9) opt.selected = true;
          sel.appendChild(opt);
        });
        sel.addEventListener('change', ()=>{
          RATE_PER_KM = parseFloat(sel.value);
          refreshCostsFromStored();
          showToast(`Rate ‚Üí ${RATE_PER_KM.toFixed(2)}/km ex GST`);
        });
        container.appendChild(label);
        container.appendChild(sel);
        setTimeout(()=>{
          const corner = document.querySelector('.mapboxgl-ctrl-top-right');
          const geocoder = document.querySelector('.mapboxgl-ctrl-geocoder');
          if(corner && geocoder){ corner.insertBefore(container, geocoder); }
        },0);
        return container;
      }
      onRemove(){ this._container?.remove(); }
    }
    return new RateControl();
  }

  // ===== Helpers =====
  const yn  = v => String(v||'').trim().toLowerCase()==='yes' || String(v||'').trim().toLowerCase()==='true';
  const num = v => { if(v==null) return NaN; const s=String(v).trim().replace(/[^\d.\-+eE]/g,''); return parseFloat(s); };
  const money = v => new Intl.NumberFormat('en-AU',{style:'currency',currency:CURRENCY,minimumFractionDigits:2,maximumFractionDigits:2}).format(v);
  const str = v => (v==null ? '' : String(v));

  function rowToFeature(row,id){
    const lat=num(row.Lat), lng=num(row.Lng);
    if (isNaN(lat) || isNaN(lng)) return null;
    row['Access Control']   = row['Access Control'] ?? row['AccessControl'] ?? '';
    row['Single Tech only'] = row['Single Tech only'] ?? row['SingleTechOnly'] ?? '';
    row.State = str(row.State).trim().toUpperCase();
    return { type:'Feature', id, geometry:{type:'Point', coordinates:[lng,lat]}, properties:row };
  }

  function loadCSV(url){
    return new Promise((resolve,reject)=>{
      Papa.parse(url,{download:true,header:true,skipEmptyLines:true,
        complete:res=>resolve(res.data), error:err=>reject(err)});
    });
  }

  async function getDriving(from,to){
    const url=`https://api.mapbox.com/directions/v5/mapbox/driving/${from[0]},${from[1]};${to[0]},${to[1]}?overview=full&geometries=geojson&access_token=${MAPBOX_TOKEN}`;
    const res=await fetch(url); const j=await res.json();
    const r=j.routes?.[0]; if(!r) throw new Error('No route');
    return { km:r.distance/1000, minutes:r.duration/60, geometry:r.geometry };
  }

  function serviceChips(p){
    const base=['CCTV','Alarm','Access Control','Install','Service'].map(k=>{
      const val = yn(p[k]);
      const color = val ? '#16a34a' : '#dc2626';
      const bg    = val ? '#dcfce7' : '#fee2e2';
      const border= val ? '#16a34a' : '#dc2626';
      return `<span style="padding:2px 6px;border:1px solid ${border};border-radius:12px;margin:2px;font-size:12px;background:${bg};color:${color};">${k}</span>`;
    }).join(' ');
    const single = yn(p['Single Tech only'])
      ? `<span style="padding:2px 8px;border:1px solid #dc2626;border-radius:12px;margin:2px;font-size:12px;background:#fee2e2;color:#dc2626;">Single Tech Only</span>`
      : '';
    return base + (single ? (' ' + single) : '');
  }

  function buildPopupHTML(p){
    const chipsHTML = serviceChips(p);
    const notes = (p.Notes && String(p.Notes).trim()) ? String(p.Notes).trim() : "";
    return `<div>
      <h3 style="margin:0 0 4px">${p.POR||''}, ${p.State||''}</h3>
      <div style="font-size:12px;color:#555;margin:6px 0"><strong>Preferred Resource:</strong> ${p['Preferred Resource']||'‚Äî'}</div>
      ${p.Phone?`<div>üìû ${p.Phone}</div>`:''}
      ${p.Email?`<div>‚úâÔ∏è <a href="mailto:${p.Email}">${p.Email}</a></div>`:''}
      <div style="margin-top:6px">${chipsHTML}</div>
      ${notes ? `<div style="margin-top:6px"><strong>Notes:</strong> ${notes}</div>` : ``}
    </div>`;
  }

  function addOrUpdateLine(map, id, color, geometry){
    if(!map.getSource(id)){
      map.addSource(id,{type:'geojson',data:{type:'FeatureCollection',features:[]}});
      map.addLayer({id, type:'line', source:id,
        paint:{'line-color':color,'line-width':3,'line-opacity':0.9}});
    }
    map.getSource(id).setData({
      type:'FeatureCollection',
      features: geometry ? [{type:'Feature',geometry,properties:{}}] : []
    });
    map.setLayoutProperty(id, 'visibility', geometry ? 'visible' : 'none');
  }
  function removeAltRoutes(map){
    ALT_COLORS.forEach((_,i)=>{
      const id=`route-alt-${i}`;
      if(map.getLayer(id)) map.removeLayer(id);
      if(map.getSource(id)) map.removeSource(id);
    });
  }

  function getAUStateAbbrevFromGeocoder(result){
    const parts = (result && result.context) || [];
    const region = parts.find(p => (p.id||'').startsWith('region.'));
    const sc = region && region.short_code;
    if(sc && sc.toUpperCase().startsWith('AU-')) return sc.slice(3).toUpperCase();
    return null;
  }

  function nearestInStateOrFallback(coord, feats, stateAbbrev){
    const from = turf.point(coord);
    const byDist = (a,b)=>a.km-b.km;

    const inState = feats
      .filter(f => String(f.properties.State).toUpperCase() === (stateAbbrev||'').toUpperCase())
      .map(f => ({feature:f, km: turf.distance(from,f,{units:'kilometers'})}))
      .sort(byDist);

    if (inState.length) return {feature: inState[0].feature, km: inState[0].km, usedFallback:false};

    const all = feats.map(f => ({feature:f, km: turf.distance(from,f,{units:'kilometers'})})).sort(byDist);
    return {feature: all[0].feature, km: all[0].km, usedFallback:true};
  }

  function alternatesSorted(coord, feats, excludeId){
    const from = turf.point(coord);
    return feats
      .filter(f=>f.id!==excludeId)
      .map(f=>({ feature:f, slKm: turf.distance(from,f,{units:'kilometers'}) }))
      .sort((a,b)=>a.slKm-b.slKm)
      .slice(0, ALT_COUNT);
  }

  const altPopups = {};
  let nearestPopup = null;
  let queryCoordGlobal = null;
  let nearestCoordGlobal = null;
  const activeAltCoords = new Map();

  function refreshCostsFromStored(){
    const km = Number(statusEl?.dataset?.nearestKm || NaN);
    const within = !isNaN(km) && km <= FREE_KM;
    let cost = 0;
    if(!isNaN(km)){
      if(!within){
        const chargeable = Math.max(0, km - FREE_KM);
        cost = chargeable * 2 * RATE_PER_KM * gstFactor();
      }
      const costEl=document.getElementById('nearest-cost');
      if(costEl) costEl.textContent=money(cost);
    }
    document.querySelectorAll('.rate-label').forEach(el=>{ el.textContent=`(${money(RATE_PER_KM)} / km ex GST)`; });
    document.querySelectorAll('.alt-cost').forEach(span=>{
      const akm=Number(span.dataset.km); if(isNaN(akm)) return;
      const altWithin = akm <= FREE_KM;
      let acost=0; if(!altWithin){ const ch=Math.max(0, akm-FREE_KM); acost=ch*2*RATE_PER_KM*gstFactor(); }
      span.textContent=money(acost);
    });
  }

  async function main(){
    await loadConfig();

    setStatus('Initialising map‚Ä¶');
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({container:'map',style:'mapbox://styles/mapbox/streets-v12',center:[144.96,-37.81],zoom:6});
    map.addControl(new mapboxgl.NavigationControl(),'bottom-right');

    let gc=new MapboxGeocoder({accessToken:MAPBOX_TOKEN,mapboxgl,marker:false,placeholder:'Search address or postcode‚Ä¶',countries:COUNTRIES});
    map.addControl(gc,'top-right');
    map.addControl(createRateControl(),'top-right');

    const rows=await loadCSV(CSV_URL);
    const feats=rows.map((r,i)=>rowToFeature(r,i)).filter(Boolean);

    showToast('C.C.');

    function ensurePointLayer(){
      if(!map.getSource('query-point')){
        map.addSource('query-point',{type:'geojson',data:{type:'FeatureCollection',features:[]}});
        map.addLayer({id:'query-point',type:'circle',source:'query-point',paint:{'circle-radius':5,'circle-color':'#111827','circle-stroke-color':'#fff','circle-stroke-width':1}});
      }
    }

    async function showNearestFrom(coord, stateAbbrev){
      try{
        ensurePointLayer();

        addOrUpdateLine(map,'route-nearest',NEAREST_COLOR,null);
        Object.values(altPopups).forEach(p => p.remove());
        for (const k in altPopups) delete altPopups[k];
        if(nearestPopup){ nearestPopup.remove(); nearestPopup=null; }
        removeAltRoutes(map);
        activeAltCoords.clear();

        map.getSource('query-point').setData({type:'FeatureCollection',features:[{type:'Feature',geometry:{type:'Point',coordinates:coord},properties:{}}]});
        queryCoordGlobal = coord;

        // Nearest: state-preferred, then edge-zone check with invisible grace
        const pick = nearestInStateOrFallback(coord, feats, stateAbbrev);
        const nearest = pick.feature;
        const slKm = pick.km;

        let within = false;
        let km=slKm, mins=(slKm/AVG_SPEED_KPH)*60, modeLabel='straight-line', routeGeom=null, usedRoad=false;

        if (slKm <= SL_TRIGGER_KM) {
          within = true; // clearly within
        } else {
          try{
            const r = await getDriving(coord, nearest.geometry.coordinates);
            const roadKm = r.km; const roadMin = r.minutes;
            if (roadKm <= FREE_KM + GRACE_KM) {
              // Invisible grace ‚Üí still within; keep SL display
              within = true;
              km = slKm; mins = (slKm/AVG_SPEED_KPH)*60; routeGeom=null; usedRoad=false; modeLabel='straight-line';
            } else {
              within = false;
              km = roadKm; mins = roadMin; routeGeom = r.geometry; usedRoad=true; modeLabel='road';
            }
          }catch(e){
            console.warn('Nearest Directions failed; fallback to SL', e);
            within = slKm <= FREE_KM;
          }
        }

        if (!within && routeGeom) addOrUpdateLine(map,'route-nearest',NEAREST_COLOR,routeGeom);
        else addOrUpdateLine(map,'route-nearest',NEAREST_COLOR,null);
        nearestCoordGlobal = nearest.geometry.coordinates;

        nearestPopup = new mapboxgl.Popup({offset:12, closeOnClick:false})
          .setLngLat(nearest.geometry.coordinates)
          .setHTML(buildPopupHTML(nearest.properties))
          .addTo(map);

        const badgeClass = within ? 'ok' : 'warn';
        const badgeText  = within ? 'Within 50 km' : 'Outside 50 km';
        const outOfStateNearest = String(nearest.properties.State).toUpperCase() !== String(stateAbbrev||'').toUpperCase();

        let travelCost = 0;
        if(!within){
          const chargeable = Math.max(0, km - FREE_KM);
          travelCost = chargeable * 2 * RATE_PER_KM * gstFactor();
        }

        const p=nearest.properties;
        const chipsHTML = serviceChips(p);

        // ===== Alternates: precheck edge-zone (35‚Äì50 km SL), else lazy =====
        const alts = alternatesSorted(coord, feats, nearest.id);

        // Precompute road checks for alternates in edge-zone
        const altCache = {}; // idx -> { prechecked, outside, km, mins, geom }
        await Promise.all(alts.map(async (a, i) => {
          if (a.slKm > SL_TRIGGER_KM && a.slKm <= FREE_KM) {
            try{
              const r = await getDriving(coord, a.feature.geometry.coordinates);
              const roadKm = r.km, roadMin = r.minutes;
              const outside = roadKm > (FREE_KM + GRACE_KM);
              altCache[i] = { prechecked:true, outside, km:roadKm, mins:roadMin, geom:r.geometry };
            }catch(e){
              console.warn('Alt precheck failed; will lazy on expand', e);
              altCache[i] = { prechecked:false };
            }
          } else {
            altCache[i] = { prechecked:false }; // clearly inside (<=35) or far outside (>50): no precheck
          }
        }));

        const altHtml = alts.map((a, i) => {
          const pf = a.feature.properties;
          const cache = altCache[i] || {prechecked:false};
          // Determine pill based on precheck (if any) or SL
          let withinAlt;
          if (cache.prechecked) {
            withinAlt = !cache.outside; // if prechecked and not outside ‚Üí within
          } else {
            withinAlt = a.slKm <= FREE_KM; // fallback to SL
          }
          const cls = withinAlt ? 'ok':'warn';
          const txt = withinAlt ? 'Within 50 km' : 'Outside 50 km';
          const isOutOfState = String(pf.State).toUpperCase() !== String(stateAbbrev||'').toUpperCase();
          return `
            <details class="alt" data-alt-index="${i}">
              <summary>
                <span>Alternate POR: ${pf.POR}, ${pf.State||''}</span>
                <span class="pill ${cls}">${txt}</span>
                ${isOutOfState ? `<span class="pill warn">Out of State</span>` : ``}
              </summary>
              <div class="alt-body" style="display:none"></div>
            </details>
          `;
        }).join('');

        setStatus(`
          <div class="row">
            <div><b>Nearest POR:</b> <span class="u">${p.POR}, ${p.State||''}</span></div>
            <div class="pill ${badgeClass}">${badgeText}</div>
            ${outOfStateNearest ? `<div class="pill warn">Out of State</div>` : ``}
          </div>
          <div class="row">
            <div class="pill"><b>Distance (One Way):</b> ${km.toFixed(1)} km <span class="muted">(${modeLabel})</span></div>
            <div class="pill"><b>Est. Time (One Way):</b> ${Math.round(mins)} min</div>
            <div class="pill">
              <b>Travel Charge inc GST:</b> <span id="nearest-cost">${money(travelCost)}</span>
              <span class="muted rate-label">(${money(RATE_PER_KM)} / km ex GST)</span>
            </div>
          </div>
          <div class="row"><div><b>Preferred Resource:</b> ${p['Preferred Resource']||'‚Äî'}</div></div>
          <div class="row">${chipsHTML}</div>
          ${(p.Notes && String(p.Notes).trim())
            ? `<div class="row"><div><b>Notes:</b> ${String(p.Notes).trim()}</div></div>`
            : ``}
          ${altHtml ? `<div class="row" style="margin-top:6px"><b>Alternates:</b></div>${altHtml}` : ''}
        `);

        // Store nearest km for rate dropdown refresh
        statusEl.dataset.nearestKm = String(within ? FREE_KM : km);

        // Wire alt toggles
        document.querySelectorAll('details.alt').forEach((el)=>{
          const idx = Number(el.dataset.altIndex);
          const alt  = alts[idx];
          const pf   = alt.feature.properties;
          const layerId = `route-alt-${idx}`;
          const color   = ALT_COLORS[idx % ALT_COLORS.length];
          const lngLat  = alt.feature.geometry.coordinates;
          const cache   = altCache[idx] || {prechecked:false};

          if(!map.getSource(layerId)){
            addOrUpdateLine(map, layerId, color, null);
          }

          el.addEventListener('toggle', async ()=>{
            const body = el.querySelector('.alt-body');

            if(el.open){
              // Fill body using cache (if prechecked) or fetch lazily
              let akm, amins, amode='straight', ageom=null, outside=false;

              if (cache.prechecked) {
                // We already know road result (outside=true means road > 65)
                if (cache.outside) {
                  akm = cache.km; amins = cache.mins; amode='driving'; ageom=cache.geom; outside=true;
                } else {
                  // within (via grace or actually inside): keep SL display, no line
                  akm = alt.slKm; amins=(akm/AVG_SPEED_KPH)*60; amode='straight'; outside=false; ageom=null;
                }
              } else if (alt.slKm > FREE_KM) {
                // Clearly outside by SL ‚Üí fetch on demand
                try{
                  const r = await getDriving(queryCoordGlobal, lngLat);
                  akm=r.km; amins=r.minutes; amode='driving'; ageom=r.geometry; outside=true;
                }catch(e){
                  console.warn('Alt Directions failed; fallback to SL', e);
                  akm=alt.slKm; amins=(akm/AVG_SPEED_KPH)*60; amode='straight'; outside=akm>FREE_KM; ageom=null;
                }
              } else {
                // Clearly inside by SL (‚â§35) ‚Üí within
                akm = alt.slKm; amins=(akm/AVG_SPEED_KPH)*60; amode='straight'; outside=false; ageom=null;
              }

              let acost=0;
              if(outside){
                const chargeable = Math.max(0, akm - FREE_KM);
                acost = chargeable * 2 * RATE_PER_KM * gstFactor();
              }

              const chips = serviceChips(pf);
              body.style.display='block';
              body.innerHTML = `
                <div class="row">
                  <div class="pill"><b>Distance (One Way):</b> ${akm.toFixed(1)} km <span class="muted">(${amode==='driving'?'road':'straight-line'})</span></div>
                  <div class="pill"><b>Est. Time (One Way):</b> ${Math.round(amins)} min</div>
                  <div class="pill"><b>Travel Charge inc GST:</b> <span class="alt-cost" data-idx="${idx}" data-km="${akm.toFixed(3)}">${money(acost)}</span> <span class="muted rate-label">(${money(RATE_PER_KM)} / km ex GST)</span></div>
                </div>
                <div class="row"><div><b>Preferred Resource:</b> ${pf['Preferred Resource']||'‚Äî'}</div></div>
                <div class="row chips">${chips}</div>
                ${(pf.Notes && String(pf.Notes).trim())
                  ? `<div class="row"><div><b>Notes:</b> ${String(pf.Notes).trim()}</div></div>`
                  : ``}
              `;

              // Draw/clear the line depending on outside
              addOrUpdateLine(map, layerId, color, (outside && ageom) ? ageom : null);

              // Popup for that pin
              const popup = new mapboxgl.Popup({offset:12, closeOnClick:false})
                .setLngLat(lngLat).setHTML(buildPopupHTML(pf)).addTo(map);
              altPopups[layerId] = popup;

              // Fit bounds with any open alternates
              activeAltCoords.set(layerId, lngLat);
              const b=new mapboxgl.LngLatBounds();
              b.extend(queryCoordGlobal); b.extend(nearestCoordGlobal);
              [...activeAltCoords.values()].forEach(c=>b.extend(c));
              map.fitBounds(b,{padding:80,maxZoom:10});

            }else{
              addOrUpdateLine(map, layerId, color, null);
              if(altPopups[layerId]){ altPopups[layerId].remove(); delete altPopups[layerId]; }
              activeAltCoords.delete(layerId);
              const b=new mapboxgl.LngLatBounds();
              b.extend(queryCoordGlobal); b.extend(nearestCoordGlobal);
              [...activeAltCoords.values()].forEach(c=>b.extend(c));
              map.fitBounds(b,{padding:80,maxZoom:10});
            }
          });
        });

        // Fit to query + nearest initially
        const b=new mapboxgl.LngLatBounds();
        b.extend(queryCoordGlobal); b.extend(nearestCoordGlobal);
        map.fitBounds(b,{padding:80,maxZoom:10});

      }catch(e){
        console.error(e);
        setStatus(`‚ùå Nearest calc error: ${e.message}`);
      }
    }

    // ==== Map load: pins, rings, and geocoder wiring ====
    map.on('load', ()=>{
      const fcPins={type:'FeatureCollection',features:feats};
      map.addSource('pins',{type:'geojson',data:fcPins});
      map.addLayer({id:'pins',type:'circle',source:'pins',
        paint:{'circle-radius':6,'circle-color':'#2563eb','circle-stroke-color':'#fff','circle-stroke-width':1}});
      map.on('mouseenter','pins',()=>map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','pins',()=>map.getCanvas().style.cursor='');
      map.on('click','pins', e=>{
        const p=e.features[0].properties;
        new mapboxgl.Popup({offset:12}).setLngLat(e.features[0].geometry.coordinates).setHTML(buildPopupHTML(p)).addTo(map);
      });

      // 50 km circles
      const rings = feats
        .filter(f => (String(f.properties.Circle50||'').toLowerCase()==='true' || yn(f.properties.Circle50)))
        .map(f => turf.circle(f.geometry.coordinates, FREE_KM, {steps:64, units:'kilometers'}));
      map.addSource('rings',{type:'geojson',data:{type:'FeatureCollection',features:rings}});
      map.addLayer({id:'rings-outline',type:'line',source:'rings',paint:{'line-color':'#f59e0b','line-width':2,'line-dasharray':[2,2]}});
      map.addLayer({id:'rings-fill',type:'fill',source:'rings',paint:{'fill-color':'#f59e0b','fill-opacity':0.08}});

      // initial view over pins
      const b=new mapboxgl.LngLatBounds(); feats.forEach(f=>b.extend(f.geometry.coordinates));
      if(!b.isEmpty()) map.fitBounds(b,{padding:60});

      // Geocoder events
      gc.on('result', e => {
        const center = e?.result?.center;
        const stateAbbrev = getAUStateAbbrevFromGeocoder(e?.result) || '';
        if (center) showNearestFrom(center, stateAbbrev);
      });
      gc.on('clear', () => {
        addOrUpdateLine(map,'route-nearest',NEAREST_COLOR,null);
        Object.values(altPopups).forEach(p => p.remove());
        for (const k in altPopups) delete altPopups[k];
        removeAltRoutes(map);
        if(nearestPopup){ nearestPopup.remove(); nearestPopup=null; }
        activeAltCoords.clear();
        if (map.getSource('query-point')) map.getSource('query-point').setData({type:'FeatureCollection',features:[]});
        setStatus('Cleared.');
      });

      setStatus(`Ready. Loaded <b>${feats.length}</b> PORs from <code>${CSV_URL}</code>. Search anywhere in Australia to calculate nearest and alternates.`);
    });
  }

  main().catch(err=>{ console.error(err); setStatus(`‚ùå Startup error: ${err.message}`); });
})();
</script>
</body>
</html>
